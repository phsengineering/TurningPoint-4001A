#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in8,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl3,  descorerLimit,  sensorTouch)
#pragma config(Sensor, I2C_1,  rightQuad,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftQuad,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           DriveLeft_1,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           DriveLeft_2,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           DriveRight_1,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           DriveRight_2,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           indexer,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           frontRoller,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           descorer,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           flywheel,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void move(int uniformSpeed) {
	motor[DriveLeft_1] = uniformSpeed;
	motor[DriveLeft_2] = uniformSpeed;
	motor[DriveRight_1] = uniformSpeed;
	motor[DriveRight_2] = uniformSpeed;
}
task turn90() {
	while((SensorValue[in8]) < 900)
	{
		//...continue turning
		motor[DriveRight_1] = -60;
		motor[DriveRight_2] = -60;
		motor[DriveLeft_1] = 60;
		motor[DriveLeft_2] = 60;
	}

	//Brief brake to stop some drift
	motor[DriveRight_1] = 60;
	motor[DriveRight_2] = 60;
	motor[DriveLeft_1] = -60;
	motor[DriveLeft_2] = -60;
	wait1Msec(139);
	move(0);
	wait(.75);
}


task main() {
	SensorValue[leftQuad] = 0;
	motor[flywheel] = -127;
	while(SensorValue[leftQuad] < 1100) {
		move(100);
		motor[frontRoller] = 127;
	}
	move(0);
	wait(.1);
	move(-127);
	wait(.15);
	move(0);
	motor[frontRoller] = 127;
	wait(.75);
	SensorValue[leftQuad] = 0;
	while(SensorValue[leftQuad] > -1055)
	{
		move(-63);
	}
	motor[flywheel] = -127;
	move(100);
	wait(.1);
	move(0);
	wait(.15);
	SensorValue[leftQuad]=0;
	SensorValue[gyro] = 0;
	startTask(turn90);
	wait(1);

	SensorValue[leftQuad] = 0;
	while(SensorValue[leftQuad] < 150) {
		move(60);
	}
	move(0);
	wait(.75);
	motor[indexer] = 127;
	wait(1);
	motor[indexer] = 0;

	SensorValue[leftQuad] = 0;
	while(SensorValue[leftQuad] < 320) {   //middle flag
		move(60);
	}
	move(0);
	wait(.75);
	motor[frontRoller] = 127;
	motor[indexer] = 127;
	wait(3);
	motor[frontRoller] = 0;
	motor[indexer] = 0;
	move(0);
	SensorValue[leftQuad] = 0;
	while(SensorValue[leftQuad] > -1600) {
		move(-127);
	}
	move(0);
  wait(.2);
  move(127);
  wait(.15);
  move(0);
  wait(1);
  SensorValue[leftQuad] = 0;
  SensorValue[gyro] = 0;
		while((SensorValue[in8]) > -900)
	{
		//...continue turning
		motor[DriveRight_1] = 60;
		motor[DriveRight_2] = 60;
		motor[DriveLeft_1] = -60;
		motor[DriveLeft_2] = -60;
	}

	//Brief brake to stop some drift
	motor[DriveRight_1] = -60;
	motor[DriveRight_2] = -60;
	motor[DriveLeft_1] = 60;
	motor[DriveLeft_2] = 60;
	wait1Msec(139);
	move(0);

move(-127);
wait(0.75);
move(127);
wait(1.5);
move(0);
 }

